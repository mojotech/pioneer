// Generated by CoffeeScript 1.7.1
var log, spawn,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

log = require('./logger');

spawn = require('child_process').spawn;

module.exports = function() {
  this.Processes = {};
  return this.Process = (function() {
    function Process(file, message, options) {
      if (options == null) {
        options = {};
      }
      this._logBuffer = __bind(this._logBuffer, this);
      this._log = __bind(this._log, this);
      this._message = __bind(this._message, this);
      this._disconnect = __bind(this._disconnect, this);
      this._close = __bind(this._close, this);
      this._error = __bind(this._error, this);
      this._exit = __bind(this._exit, this);
      this._stderr = __bind(this._stderr, this);
      this._stdout = __bind(this._stdout, this);
      this.stop = __bind(this.stop, this);
      this.file = file;
      this.message = message;
      _.extend(this.options, options);
    }

    Process.prototype.start = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!this._started) {
        this._started = $.defer();
        this._process = spawn('node', [this.file].concat(args));
        this._process.stdout.on('data', this._stdout);
        this._process.stderr.on('data', this._stderr);
        this._process.on('exit', this._exit);
        this._process.on('error', this._error);
        this._process.on('close', this._close);
        this._process.on('disconnect', this._disconnect);
        this._process.on('message', this._message);
        process.on('exit', this.stop);
        process.on('error', this.stop);
      }
      return this._started.promise;
    };

    Process.prototype.stop = function() {
      if (this._process) {
        this._process.kill() && (this._process = null);
      }
      return $.fulfilled(!this._process);
    };

    Process.prototype._stdout = function(data) {
      this._logBuffer(log.info, "STDOUT", data);
      if (this._started.promise.isPending()) {
        if (~data.toString().indexOf(this.message)) {
          return this._started.fulfill();
        }
      }
    };

    Process.prototype._stderr = function(data) {
      return this._logBuffer(log.warn, "STDERR", data);
    };

    Process.prototype._exit = function(code, signal) {
      return this._log(log.error, "EXIT", [code, signal].join(', '));
    };

    Process.prototype._error = function(error) {
      return this._started.reject(error);
    };

    Process.prototype._close = function(code, signal) {
      return this._log(log.warn, "CLOSE", [code, signal].join(', '));
    };

    Process.prototype._disconnect = function() {
      return this._log(log.info, "DISCONNECT");
    };

    Process.prototype._message = function(message) {
      return this._log(log.info, "MESSAGE", message);
    };

    Process.prototype._log = function(logger, type, data) {
      if (data) {
        return logger("" + this.file + ":" + type + " - " + data);
      }
    };

    Process.prototype._logBuffer = function(logger, type, buffer) {
      var line, _i, _len, _ref, _results;
      _ref = buffer.toString().split("\n");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _results.push(this._log(logger, type, line));
      }
      return _results;
    };

    return Process;

  })();
};
